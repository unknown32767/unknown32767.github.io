---
layout: post
title: "Jenkins的配置和一些打包相关"
date: 2025-09-18 14:00:00 +0800
categories: blog
---

# Jenkins

目前为止，《麦琪的花园》的CI（姑且算是）是我做的，主要工作就是部署了Jenkins和打包管线。

部署Jenkins比较平凡，跟着[文档](https://www.jenkins.io/doc/book/installing/windows/)做就行了。

Pipeline根据[文档](https://www.jenkins.io/doc/book/pipeline/#pipeline-syntax-overview)的说法，旧的Scripted syntax更接近Groovy原生语法，能直接调用Groovy接口，Declarative pipeline则可读性更好；既然示例都用的Declarative版本，那就从善如流用这个版本了。

根据需要也装了一些插件：工作区管理，git仓库等，这些插件的用法都在各自插件的文档里有示例pipeline写法。

关键的还是打包本身需要的命令，第一想法自然是去看看UBT的“文档”（没有官方文档，比较全的是[这里](https://unreal-garden.com/docs/command-line-arguments/)），但是怎么保证手写的命令和正常从editor里打包的命令一致呢？

注意到VS编译editor的时候也是用的UBT，那么检查项目设置就能发现编译和清理editor的命令：

```bat
$(BuildBatchScript) -Target="TARGETNAME Win64 Development -Project=\"PROJECT_PATH\"" -Target="ShaderCompileWorker Win64 Development -Quiet" -WaitMutex -FromMsBuild

$(CleanBatchScript) -Target="TARGETNAME Win64 Development -Project=\"$PROJECT_PATH\"" -Target="ShaderCompileWorker Win64 Development -Quiet" -WaitMutex -FromMsBuild
```

对于打包，在editor执行打包时就能看见对应的命令：

```bat
"${UE_PATH}\\Engine\\Build\\BatchFiles\\RunUAT.bat" BuildCookRun
-ScriptsForProject="${env.UPROJECT_PATH}"
-nop4
-utf8output
-nocompileeditor
-skipbuildeditor
-cook
-project="${env.UPROJECT_PATH}"
-target=${PROJECT_NAME}
-unrealexe="${UE_PATH}\\Engine\\Binaries\\Win64\\UnrealEditor-Cmd.exe"
-platform=Win64
-stage
-archive
-package
-build
-pak
-iostore
-compressed
-prereqs
-archivedirectory="${env.OUTPUT_DIR}"
-clientconfig=${params.Configuration}
-serverconfig=${params.Configuration}
-nocompile
-nocompileuat
-nodebuginfo
-clean
```

于是这样整个流程中的关键命令就到齐了，测试之后发现还需要处理一些git超时、sentry debug symbol上传超时之类的事情，这些就因项目而异了，按下不表。

# 无法用公版引擎打的包

除了对外的标准Shipping包，也会有只有在Shipping包中才出现的问题，这时候就需要一个带log的Shipping包。

```C#
//PROJECTNAME.target.cs
if (Configuration == UnrealTargetConfiguration.Shipping)
{
    BuildEnvironment = TargetBuildEnvironment.Unique;
    bUseLoggingInShipping = true;

    ...
}
```

查找性能瓶颈的时候，会需要一个带trace的shipping包。[Advanced Debugging in Unreal Engine](https://dev.epicgames.com/community/learning/tutorials/dXl5/advanced-debugging-in-unreal-engine)提到添加`UE_TRACE_ENABLED=1`就能给shipping包加上trace，但实际上这是不完整的。

查看一个Trace宏，比如`TRACE_CPUPROFILER_EVENT_XXX`系列宏所在的文件`CpuProfilerTrace.h`可以发现，不覆盖宏`CPUPROFILERTRACE_ENABLED`的定义的话Shipping包中仍会关掉这些trace。

```cpp
#if !defined(CPUPROFILERTRACE_ENABLED)
#if UE_TRACE_ENABLED && !UE_BUILD_SHIPPING
#define CPUPROFILERTRACE_ENABLED 1
#else
#define CPUPROFILERTRACE_ENABLED 0
#endif
#endif
```

所以最终我们需要往target.cs里加上这么一堆定义：

```C#
//PROJECTNAME.target.cs
if (Configuration == UnrealTargetConfiguration.Shipping)
{
    ...

    GlobalDefinitions.Add("UE_TRACE_ENABLED=1");
    GlobalDefinitions.Add("STATSTRACE_ENABLED=1");
    GlobalDefinitions.Add("LOGTRACE_ENABLED=1");
    GlobalDefinitions.Add("MISCTRACE_ENABLED=1");
    GlobalDefinitions.Add("COUNTERSTRACE_ENABLED=1");
    GlobalDefinitions.Add("LOADTIMEPROFILERTRACE_ENABLED=1");
    GlobalDefinitions.Add("CPUPROFILERTRACE_ENABLED=1");
    GlobalDefinitions.Add("GPUPROFILERTRACE_ENABLED=1");
    GlobalDefinitions.Add("UE_NET_TRACE_ENABLED=1");
    GlobalDefinitions.Add("ENABLE_NAMED_EVENTS=1");
    GlobalDefinitions.Add("ENABLE_STATNAMEDEVENTS=1");
}
```

这篇文章顺便还解决了我很久以来的一个疑惑，即Debug、Development、Shipping这些Configuration之间到底有什么差别（[这一段](https://dev.epicgames.com/community/learning/tutorials/dXl5/advanced-debugging-in-unreal-engine#buildconfigurations)）。

同时这篇文章还提到今年3月VS提供的新技术，[Dynamic Debugging](https://devblogs.microsoft.com/cppblog/cpp-dynamic-debugging-full-debuggability-for-optimized-builds/)已经可以在5.6中使用了。看起来原理是在（按编译参数）编译优化过的代码的同时仍编译一份不经优化的版本，在代码被打上断点的时候“偷偷”把实现替换成未优化版，这样Debugger能获得更全面的上下文信息。

不过因为这玩意5.6才能用，而且Rider似乎还没支持（可能要等很久？因为Rider的调试后端应该是基于LLVM的），暂时是没法尝试了。