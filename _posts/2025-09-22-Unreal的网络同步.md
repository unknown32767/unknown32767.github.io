---
layout: post
title: "Unreal的网络同步"
date: 2025-09-22 05:00:00 +0800
categories: blog
---

4月的时候我开始负责重构《麦琪的花园》的容器系统（背包、快捷栏、装备栏等各种能放东西的地方都是容器），一方面是以前的容器在蓝图侧，需要移动到cpp以期提高数据结构的可读性和效率；另一方面则是当时期望今年下旬测试的时候能加入多人模式，需要将给各个系统加上网络同步。

UE的网络同步相当复杂，做的时候只能说粗略的了解了一下整体概念：
- 作为同步最小单元的是Actor，通过`UPROPERTY`或者蓝图指定`Replicated`属性来标记Actor中需要同步的属性。
- 这些需要同步的属性会保存在`FRepLayout`中，旧状态由`FRepState`保存，在同步时检查到差异后由`FObjectReplicator`去处理改动。
- 每个Actor实例都会有一个单独的`ActorChannel`用来发送、接受改动、调用RPC。
- 这些Channel会归属于一个`UNetConnection`，即一个服务器与客户端的连接（奇妙的是`UNetConnection`继承了`UPlayer`，可能是远端在本地的体现就是一个`UNetConnection`？）
- 这些Connection使用`UNetDriver`来进行通信，它负责真正在网络上收发数据包，一般而言是通过UE自己实现的UDPSocket（好像大家都喜欢基于UDP+修正来做可靠传输？）

不过具体实现需要的容器同步倒是没有太复杂，一些有用的东西记录如下：

容器作为一个UObject需要声明自己能被网络同步，即重写`UObject::IsSupportedForNetworking`，注意UObject本来的实现是只有当UObject是从Package中直接载入的时候才能同步，这里改成true之后则需要在使用它的地方手动声明它的同步：

```cpp
UItemContainerComponentBase::UItemContainerComponentBase()
{
	SetIsReplicatedByDefault(true);
	bReplicateUsingRegisteredSubObjectList = true;
	bWantsInitializeComponent = true;
}

UItemContainerComponent::UItemContainerComponent()
{
	ItemContainer = CreateDefaultSubobject<UItemContainer>(TEXT("ItemContainer"));

	AddReplicatedSubObject(ItemContainer);
}
```

作为客户端，收到信息的时候处理反而要比服务端简单：

```cpp
class UItemContainer : public UObject
{
	GENERATED_BODY()

public:
	UFUNCTION()
	void OnRep_Items(const TArray<FItemData>& PrevItems);
	UPROPERTY(BlueprintReadWrite, EditAnywhere, SaveGame, ReplicatedUsing = OnRep_Items)
	TArray<FItemData> Items;

    ...
}

void UItemContainer::OnRep_Items(const TArray<FItemData>& PrevItems)
{
	for (int i = 0; i < Items.Num(); i++)
	{
		if (Items[i] != PrevItems[i])
		{
			if (Items[i].ItemID != PrevItems[i].ItemID)
			{
				Items[i].UpdateItemConfig();
			}

			FGameplayTag Channel = Items[i].ItemID == PrevItems[i].ItemID
				                       ? Tag_ItemContainer_ItemUpdated
				                       : Tag_ItemContainer_ItemChanged;
			BROADCAST_ITEM_CHANGE(this, i, Channel);
		}
	}
}
```

客户端只需要对比数据差异来计算发生了什么就好，而服务端则只能在各种操作之后手动去广播事件，所以代码的复用性至关重要：让各种容器操作由几个原子操作构成，只有原子操作才会在服务端广播事件。

但这样一来，客户端就失去了获得物品时的上下文（比如玩家主动捡起物品和整理背包的时候，客户端都只会发现背包内的物品数量发生了变动，但是只有主动捡起物品时才希望显示通知），于是写出了第一个Client RPC：

```cpp
UFUNCTION(Client, Unreliable)
void BroadcastGetItem(const FName& ItemID, const int32 ItemCount) const;
```

因为服务端有相关上下文，于是在需要显示通知的时候作为一个RPC调用让对应的那个客户端去广播相应内容就好。

顺带一提，蓝图中对同步属性的赋值则是通过反射自动去加上服务端对RepNotify的调用：

```cpp
//VariableSetHandler.cpp:202
if (SetNotify->HasLocalRepNotify())
{
	UK2Node_CallFunction* CallFuncNode = Node->GetGraph()->CreateIntermediateNode<UK2Node_CallFunction>();
	CallFuncNode->FunctionReference.SetExternalMember(SetNotify->GetRepNotifyName(), SetNotify->GetVariableSourceClass() );
	CallFuncNode->AllocateDefaultPins();

	// Copy self pin
	UEdGraphPin* NewSelfPin = CallFuncNode->FindPinChecked(UEdGraphSchema_K2::PN_Self);
	UEdGraphPin* OldSelfPin = Node->FindPinChecked(UEdGraphSchema_K2::PN_Self);
	NewSelfPin->CopyPersistentDataFromOldPin(*OldSelfPin);

	// link Set Node -> new CallFuncNode
	UEdGraphPin* OldThenPin = Node->FindPin(UEdGraphSchema_K2::PN_Then);
	check(OldThenPin);

	UEdGraphPin* NewThenPin = CallFuncNode->GetThenPin();
	if (ensure(NewThenPin))
	{
		// Link Set Node -> Notify
		NewThenPin->CopyPersistentDataFromOldPin(*OldThenPin);
		OldThenPin->BreakAllPinLinks();
		OldThenPin->MakeLinkTo(CallFuncNode->GetExecPin());
	}
}
```