---
layout: post
title: "一些疑难杂症"
date: 2025-09-22 08:00:00 +0800
categories: blog
---

实际上开发下来期间还碰上了一些迫于时间无法深究的问题，整理如下：

# K2_DestroyComponent会检查调用者是否是所有者

```cpp
//ActorComponent.cpp:1489
void UActorComponent::K2_DestroyComponent(UObject* Object)
{
	AActor* MyOwner = GetOwner();
	if (bAllowAnyoneToDestroyMe || Object == this || MyOwner == NULL || MyOwner == Object)
	{
		DestroyComponent();
	}
	else
	{
		// TODO: Put in Message Log
		UE_LOG(LogActorComponent, Error, TEXT("May not destroy component %s owned by %s."), *GetFullName(), *MyOwner->GetFullName());
	}
}
```

也许是为了蓝图的安全性，避免其他蓝图误销毁Component？但无法构造出一个这个检查有用的场景，总感觉怪怪的。

# EnhancedInput无法响应一帧内的事件

即如果按键在同一帧内按下又松开，则不会触发任何EnhancedInput的响应。

```cpp
//EnhancedPlayerInput.cpp:408
// Establish update type.
bool bDownLastTick = KeyDownPrevious.FindRef(Mapping.Key);
// TODO: Can't just use bDown as paired axis event edges may not fire due to axial deadzoning/missing axis properties. Need to change how this is detected in PlayerInput.cpp.
bool bKeyIsDown = KeyState && (KeyState->bDown || KeyState->EventCounts[IE_Pressed].Num() || KeyState->EventCounts[IE_Repeat].Num());
// Analog inputs should pulse every (non-zero) tick to retain compatibility with UE4. TODO: This would be better handled at the device level.
bKeyIsDown |= Mapping.Key.IsAnalog() && RawKeyValue.SizeSquared() > 0;

bool bKeyIsReleased = !bKeyIsDown && bDownLastTick;
bool bKeyIsHeld = bKeyIsDown && bDownLastTick;
```

原因似乎是这里只会将按键状态与上一帧的比较，自然如果按键只在一帧之内按下松开，则两次按键的状态是相同的。而原版PlayerInput没有这个问题也许是因为`UPlayerInput::EvaluateInputDelegates`里没有与上一帧的状态对比，按下就广播pressed，松开就广播released？

但是没有找到修复/改进的方法，而且因为是极端帧率下才会出现的问题就放在一边不管了。

# IncludeOrder导致的无法打包

7月的时候编译期间报过找不到头文件的错误，但是项目结构没有更改过，在将Target.cs中的IncludeOrderVersion降低到5.1后编译通过。

因为短时间内没找到5.1和5.3之间IncludeOrder的差异就没有深究。

```C#
IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_1;
```

# ToolTip在dpi scale低于1时表现很差

或者说因为software cursor的大小不随dpi scale变化而变化，导致只有窗口的dpi scale恰为1时，设置了Tooltip Widget的tooltip才会按software cursor的大小正确的算出偏移，如果dpi小于1，则tooltip会被鼠标遮住，如果dpi大于1，则tooltip与鼠标间会有缝隙。

有点细枝末节的问题，但是考虑到一般dpi curve都是以1920*1080下dpi为1做基准，玩家显示器开始普及4k的现在，其实还挺容易碰到这种现象的。

# Shipping包内，某个函数名无法注册lua绑定

某个蓝图函数的lua实现无法绑定，具体表现是Shipping包中执行到`FFunctionRegistry::Invoke`后，总是拿不到lua中的同名luafunction，但是改名（加下划线）后就可以。

可能是蓝图序列化中出现了问题，导致函数名和显示的不一样？因为很难复现和测试，并且能（在不清楚原因的状况下）修好就没有细究了。

```cpp
//FunctionRegistry.cpp:35
const auto Exists = LuaFunctions.Find(Function);
if (Exists)
{
	FuncRef = Exists->LuaRef;
	FuncDesc = Exists->Desc.Get();
}
else
{
	FuncRef = LUA_NOREF;
	FuncDesc = new FFunctionDesc(Function, nullptr);

	lua_rawgeti(L, LUA_REGISTRYINDEX, SelfRef);
	lua_getmetatable(L, -1);
	do
	{
		lua_pushstring(L, FuncDesc->GetLuaFunctionName());
		lua_rawget(L, -2);
		if (lua_isfunction(L, -1))
		{
			lua_pushvalue(L, -3);
			lua_remove(L, -3);
			lua_remove(L, -3);
			lua_pushvalue(L, -2);
			FuncRef = luaL_ref(L, LUA_REGISTRYINDEX);
			break;
		}
		lua_pop(L, 1);
		lua_pushstring(L, "Super");
		lua_rawget(L, -2);
		lua_remove(L, -2);
	}
	while (lua_istable(L, -1));
	lua_pop(L, 2);

	FFunctionInfo Info;
	Info.LuaRef = FuncRef;
	Info.Desc = TUniquePtr<FFunctionDesc>(FuncDesc);
	LuaFunctions.Add(Function, MoveTemp(Info));
}
//这里执行完后FuncRef总是NOREF

if (FuncRef == LUA_NOREF)
{
	const auto Overridden = Function->GetOverridden();
	if (Overridden && Stack.Code)
	//总是会执行到这里
		Overridden->Invoke(Context, Stack, RESULT_PARAM);
	return;
}
FuncDesc->CallLua(L, FuncRef, SelfRef, Stack, RESULT_PARAM);
```
